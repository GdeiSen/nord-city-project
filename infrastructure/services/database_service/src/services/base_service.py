import logging
from functools import wraps
from typing import Type, TypeVar, Any, Optional, List, Dict

from sqlalchemy.orm import DeclarativeBase
from database.database_manager import DatabaseManager
from shared.utils.converter import Converter

ModelType = TypeVar('ModelType', bound=DeclarativeBase)

logger = logging.getLogger(__name__)

def db_session_manager(func):
    """
    A decorator that manages database sessions for service methods.
    It provides a `session` keyword argument, handles transactions, and logs exceptions.
    """
    @wraps(func)
    async def wrapper(self: 'BaseService', *args, **kwargs):
        if not hasattr(self, 'db_manager') or not isinstance(self.db_manager, DatabaseManager):
            raise TypeError(f"Object {self.__class__.__name__} needs a 'db_manager' to use @db_session_manager.")

        # Ensure session is not passed manually
        kwargs.pop('session', None)

        try:
            async with self.db_manager.get_session() as session:
                return await func(self, *args, session=session, **kwargs)
        except Exception as e:
            logger.error(
                f"Exception in service method '{self.__class__.__name__}.{func.__name__}': {e}",
                exc_info=True
            )
            raise
    return wrapper


class BaseService:
    """
    A generic base service providing standard CRUD operations.
    It works directly with SQLAlchemy model instances. Subclasses must define 'model_class'.
    """
    model_class: Type[ModelType] = None

    def __init__(self, db_manager: DatabaseManager):
        """
        Initializes the service with a DatabaseManager instance.

        Args:
            db_manager: The central manager for database resources.
        """
        if self.model_class is None:
            raise NotImplementedError(f"{self.__class__.__name__} must define a 'model_class' attribute.")
        self.db_manager = db_manager
        self.repository = self.db_manager.repositories.get(self.model_class)

    @db_session_manager
    async def create(self, *, session, model_instance: ModelType) -> Optional[ModelType]:
        """
        Creates a new entity in the database from a model instance.
        ID will be automatically generated by PostgreSQL sequences for models with autoincrement.

        Args:
            session: The active SQLAlchemy session (from decorator).
            model_instance: The SQLAlchemy model instance to create (или dict, если вызвано через RPC).

        Returns:
            The created SQLAlchemy model instance.
        """
        # Если model_instance — dict, преобразуем в модель
        if isinstance(model_instance, dict):
            model_instance = Converter.from_dict(self.model_class, model_instance)
        
        created_instance = await self.repository.create(session=session, obj_in=model_instance)
        if created_instance is None:
            raise Exception(f"Failed to create new {self.model_class.__name__} in the database.")
        logger.info(f"{self.model_class.__name__} created with ID: {getattr(created_instance, 'id', 'N/A')}")
        return created_instance

    @db_session_manager
    async def get_by_id(self, *, session, entity_id: Any) -> Optional[ModelType]:
        """Retrieves an entity by its primary key."""
        return await self.repository.get_by_id(session=session, entity_id=entity_id)

    @db_session_manager
    async def get_all(self, *, session) -> List[ModelType]:
        """Retrieves all entities of this type."""
        return await self.repository.get_all(session=session)

    @db_session_manager
    async def get_paginated(
        self,
        *,
        session,
        page: int = 1,
        page_size: int = 10,
        sort: Optional[List[Dict[str, Any]]] = None,
        filters: Optional[List[Dict[str, Any]]] = None,
        search: Optional[str] = None,
        search_columns: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """Returns paginated {items: [...], total: int}."""
        return await self.repository.get_paginated(
            session=session,
            page=page,
            page_size=page_size,
            sort=sort,
            filters=filters,
            search=search,
            search_columns=search_columns,
        )

    @db_session_manager
    async def update(self, *, session, entity_id: Any, update_data: Dict[str, Any]) -> Optional[ModelType]:
        """
        Updates an existing entity from a dictionary of changes.

        Args:
            session: The active SQLAlchemy session.
            entity_id: The primary key of the entity to update.
            update_data: A dictionary containing the fields to update.

        Returns:
            The updated SQLAlchemy model instance or None if not found.
        """
        existing_model = await self.repository.get_by_id(session=session, entity_id=entity_id)
        if not existing_model:
            return None

        # Apply updates from the dictionary to the model instance
        for field, value in update_data.items():
            if hasattr(existing_model, field):
                setattr(existing_model, field, value)
            else:
                logger.warning(f"Field '{field}' on model {self.model_class.__name__} ignored during update.")

        updated_instance = await self.repository.update(session=session, obj_in=existing_model)
        if updated_instance:
            logger.info(f"{self.model_class.__name__} with ID {entity_id} was updated.")
        return updated_instance

    @db_session_manager
    async def delete(self, *, session, entity_id: Any) -> bool:
        """Deletes an entity by its primary key."""
        return await self.repository.delete(session=session, entity_id=entity_id)

    @db_session_manager
    async def find(self, *, session, filters: Dict[str, Any]) -> List[ModelType]:
        """Finds entities that match the given filters."""
        return await self.repository.find(session=session, **filters)