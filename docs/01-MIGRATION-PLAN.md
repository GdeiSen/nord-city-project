# План миграции

Документ задаёт четыре основных направления миграции и порядок работ.

**1. Отказ от RabbitMQ и полное удаление всей логики. Рефакторинг и отход от Docker.**

Сейчас bot_service и web_service обращаются к database_service через RabbitMQ: запросы попадают в очередь, database_service слушает очередь и отвечает. В коде используются aio_pika, RabbitMQClient, переменные RABBITMQ_*. После миграции RabbitMQ не используется. Вся логика очередей, подключений к брокеру и RPC через очереди удаляется из кодовой базы. Database_service перестаёт слушать очередь и вместо этого поднимает HTTP-сервер (FastAPI); bot и web вызывают его по HTTP. Параллельно выполняется отход от Docker: все компоненты (PostgreSQL, database_service, bot_service, web_service, Next.js) запускаются на хосте как обычные процессы. Инструкция по локальному запуску после миграции приведена в RUN-WITHOUT-DOCKER.md; разделы про установку и настройку RabbitMQ из неё убираются, переменные окружения переключаются на адреса HTTP-сервисов.

**2. Создание удобного общего класса с логикой FastAPI и клиентов по паттерну прокси.**

В shared создаётся общий класс, который реализует всю логику вызова по HTTP: формирование тела запроса (service, method, params), отправка POST на заданный base_url (например, database_service), разбор JSON-ответа в структуру success/data/error. Этот класс не знает о доменных типах; он только передаёт и получает словари. На его основе строятся клиенты для конкретных сервисов. DatabaseClient обращается к database_service: внутри использует общий класс, снаружи предоставляет явно перечисленные методы (user.get_by_id, user.get_all, user.create, auth.get_by_id, space.find, service_ticket.get_stats и т.д.) с типизацией через ваши модели. Аналогично при необходимости вводятся BotClient (вызовы к bot_service) и WebAuthClient или аналог (вызовы к web_service из бота для аутентификации). Подключил клиент, выставил URL в конфиге — и пользуешься методами как прокси, без ручной сборки запросов. Детали общего класса и клиентов — в 02-HTTP-ARCHITECTURE.md.

**3. Переработка web_service: все эндпоинты указаны явно; уход от кастылей с бесконечной сериализацией.**

Сейчас маршруты в web_service генерируются через BaseApiRouter: по одному шаблону на ресурс создаются одни и те же CRUD-эндпоинты, плюс add_custom_endpoint для особых случаев. Типы заданы одним DTO на ресурс; в обработчиках происходит неочевидная цепочка: принять тело, преобразовать в словарь, отправить в db_client, получить ответ, провалидировать через DTO, при необходимости снова сериализовать. После переработки BaseApiRouter и add_custom_endpoint не используются. Каждый эндпоинт задаётся отдельным обработчиком с явно указанными типами запроса (body) и ответа (response_model). Логика простая: принять данные, вызвать соответствующий метод db_client, по ответу вернуть данные в нужном виде или поднять HTTPException. Никакой бесконечной сериализации в разные промежуточные модели; один входной тип на эндпоинт, один выходной. Полная таблица эндпоинтов и структура роутеров — в 03-WEB-SERVICE-EXPLICIT-API.md.

**4. Модели между сервисами — базовые со всеми полями; для сайта — request/response DTO с учётом API.**

Между сервисами (database_service, bot_service, web_service) по HTTP передаются данные в виде, совпадающем с вашими базовыми моделями: все поля сущности, без искусственного разделения на «только для создания» или «только для ответа» на уровне транспорта. То есть при вызове database_service из web или бота используются те же структуры (словари/модели с полным набором полей), которые уже есть в shared (модели, DTO или их сериализация). Для работы сайта отдельно определяются request- и response-DTO: что именно фронт отправляет в теле запроса и что ожидает в ответе. Эти DTO должны соответствовать контракту API, которым пользуется фронт. Контракт задаётся в web/: в web/lib/api.ts видны эндпоинты и типы (User, ServiceTicket, RentalSpace и т.д.), в web/types/index.ts — интерфейсы сущностей и поля. Request/response DTO в web_service нужно спроектировать так, чтобы поля и форматы совпадали с тем, что ожидает фронт (например, create принимает Omit<Entity, 'id' | 'created_at' | 'updated_at'>, update — Partial<Entity>, ответы — сущность или список сущностей с полями из types). Подробнее — в 04-REQUEST-RESPONSE-MODELS.md.

**Порядок работ.**

Сначала переработка web_service на явные эндпоинты при сохранении текущего способа вызова database_service (через RabbitMQ): вводятся request/response схемы под контракт сайта, явные роутеры, в main подключаются они вместо BaseApiRouter. Так устраняются кастыли с сериализацией и фиксируется полный список эндпоинтов. Затем в database_service добавляется HTTP-сервер (один эндпоинт, например POST /internal/rpc) с тем же обработчиком, что сейчас обрабатывает RPC из очереди. В shared реализуется общий HTTP-клиент и на его основе переписывается DatabaseClient с явными методами; bot и web переключаются на этот клиент. После этого из всех сервисов удаляется логика RabbitMQ (подключения, очереди, переменные). При необходимости добавляются HTTP-эндпоинты в bot_service и web_service для вызовов друг друга и клиенты BotClient/WebAuthClient. В конце обновляется RUN-WITHOUT-DOCKER.md: без RabbitMQ, с переменными для URL сервисов (DATABASE_SERVICE_HTTP_URL и т.д.).

**Переменные окружения после миграции.** PostgreSQL: DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD. Database_service: хост и порт своего HTTP-сервера (например 8001). Bot_service и web_service: DATABASE_SERVICE_HTTP_URL (например http://127.0.0.1:8001); при вызовах между вебом и ботом — соответствующие URL. Next.js: NEXT_PUBLIC_API_URL на web_service. CORS и ROOT_PATH для web_service без изменений.
