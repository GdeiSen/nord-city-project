# Связь сервисов по HTTP: общий класс и клиенты (прокси)

Сервисы общаются по HTTP и JSON. В shared вводится один общий класс, который реализует логику вызова (отправка запроса, разбор ответа); на его основе строятся клиенты для database_service, при необходимости для web_service и bot_service. Клиенты предоставляют явный набор методов и используются по паттерну прокси: подключил, настроил URL — и вызываешь методы без ручной сборки HTTP.

**Эндпоинт в database_service.**

Database_service поднимает FastAPI на выбранном порту (например 8001). Достаточно одного внутреннего маршрута, например POST /internal/rpc. Тело запроса — JSON с полями service (строка), method (строка), params (объект с аргументами). Ответ — JSON с полями success (bool), data (объект или null), error (строка или null). Обработчик этого маршрута принимает словарь, по service и method находит нужный сервис и метод в уже зарегистрированных сервисах (та же логика, что сейчас в _rpc_handler при обработке сообщения из RabbitMQ), передаёт params, получает результат и возвращает success/data/error. Таким образом, бизнес-логика database_service не меняется; меняется только способ доставки запроса — HTTP вместо очереди. По желанию добавляется GET /health для проверки состояния. Вся логика подключения к RabbitMQ, объявления очередей и потребления сообщений из database_service удаляется.

**Общий класс для HTTP-вызовов (shared).**

В shared (например, shared/clients/http_rpc_client.py или shared/utils/http_client.py) создаётся класс, который инкапсулирует всю логику вызова. Конструктор принимает base_url (например http://127.0.0.1:8001) и опционально timeout. Метод call(service, method, params) формирует тело {"service": service, "method": method, "params": params}, отправляет POST на base_url/internal/rpc (или другой зафиксированный путь), разбирает JSON-ответ и возвращает dict с ключами success, data, error. При сетевой ошибке или неверном ответе можно пробрасывать исключение или возвращать dict с success=False. Этот класс не знает о доменных типах (User, Space, ServiceTicket и т.д.); он только передаёт и получает словари. Переменные окружения (base_url или host/port) читаются при инициализации или из конфига.

**DatabaseClient как прокси с явными методами.**

DatabaseClient остаётся фасадом для web_service и bot_service, но внутри использует общий HTTP-класс вместо RabbitMQ. Снаружи интерфейс тот же: db_client.user.get_by_id(entity_id), db_client.user.get_all(), db_client.service_ticket.get_stats() и т.д. Каждый метод явно перечислен: для user — get_by_id, get_all, create, update, delete; для auth — то же, с учётом того что идентификатор — user_id; для feedback, object, poll, service_ticket_log, space_view — стандартный CRUD; для service_ticket дополнительно find(filters) и get_stats(); для space дополнительно find(filters). Внутри метода формируются params (словарь, сериализуемый в JSON), вызывается общий класс call(service, method, params), по ответу при необходимости data конвертируется в нужную модель (Converter.from_dict или model_validate) и возвращается либо dict с success/data/error, либо типизированный результат. Список методов и сигнатуры задаются явно в коде клиента, чтобы было понятно, чем можно пользоваться и с какими типами. Подключение: при старте приложения создаётся экземпляр общего HTTP-клиента и DatabaseClient использует его; URL берётся из DATABASE_SERVICE_HTTP_URL или из отдельных переменных.

**BotClient и клиент к web_service (при необходимости).**

Если web_service должен вызывать bot_service (например, отправить уведомление в Telegram), в bot_service добавляется HTTP-сервер с нужными эндпоинтами, а в shared — BotClient с явными методами (send_notification и т.п.), внутри которого тот же подход: общий HTTP-клиент или прямой httpx к base_url bot_service. Если бот должен вызывать web_service (аутентификация через Telegram), в web_service добавляются внутренние эндпоинты, а в shared — клиент (например WebAuthClient) с явными методами (validate_telegram_user, get_auth_by_telegram_id и т.д.), внутри — HTTP-вызовы к web_service. В обоих случаях паттерн один: общая логика отправки/приёма в одном месте, снаружи — типизированный прокси с перечислением методов. Подключил клиент, указал URL — и пользуешься методами без ручного формирования запросов.

**Итог.**

Один общий класс реализует логику FastAPI-вызова (в смысле «вызов по HTTP к сервису, который на FastAPI»): тело запроса, отправка, разбор ответа. На его основе строятся клиенты для db_service, web_service и bot_service с явным указанием всех методов; использование как прокси. RabbitMQ из кода полностью удаляется; связь только по HTTP.
